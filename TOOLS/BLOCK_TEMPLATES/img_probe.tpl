<BLOCK>
<LICENSE>
/*
 * (c) 2006 AUTHOR_NAME 
 */

</LICENSE>
<BLOCK_NAME>
BLOCK_NAME_REPLACE
</BLOCK_NAME> 


<DESC_SHORT>
Add short description here. Will appear in HTML documentation.
</DESC_SHORT>

<COMMENTS>
<![CDATA[ 

/*
 * 		BLOCK_NAME_REPLACE()
 *
 * Generated by blockgen
 *
 * Image Probe Block
 * Notes:
 *    This is a block generated from the image probe template
 *    It will input a sample, and print it to the console. If an
 *    output buffer is connected, the input sample 
 *    is outputted unmodified
 * 
 *    
 * Programmer: 
 * Date: 
 * Modified: 
 *
 */
]]>
</COMMENTS> 

<DECLARATIONS> 

	int i,j,k;
	int ii,jj;
	float fpixel;
	image_t img;

</DECLARATIONS> 




<STATES>
	<STATE>
		<TYPE> int </TYPE>
		<NAME> numberInputBuffers </NAME>
	</STATE>
	<STATE>
		<TYPE> int </TYPE>
		<NAME> numberOutputBuffers </NAME>
	</STATE>
	<STATE>
		<TYPE> int </TYPE>
		<NAME> stateVariable </NAME>
		<VALUE> 0 </VALUE>
	</STATE>
</STATES>



<PARAMETERS>
	<PARAM>
		<DEF> Sample Parameter Definition </DEF>
		<TYPE> float </TYPE>
		<NAME> thisSampleParameter </NAME>
		<VALUE> 1999.99 </VALUE>
	</PARAM>
</PARAMETERS>

<INIT_CODE>
<![CDATA[ 

   /*
    * Get the number of input buffers.
    * return if none connected with an error
    */
   if((numberInputBuffers = NO_INPUT_BUFFERS()) <= 0) {
	   fprintf(stderr,"BLOCK_NAME_REPLACE: no input buffers\n");
	   return(1);
   }
   /*
    * Get the number of output buffers.
    * return if greater then number of input buffers with an error
    */
   if((numberOutputBuffers = NO_OUTPUT_BUFFERS()) > numberInputBuffers) {
	  fprintf(stderr,"BLOCK_NAME_REPLACE: more output than input buffers\n");
	  return(2);
   }
   /*
    * set buffer sizes to int
    */
   for(i=0; i< numberInputBuffers; i++)
			SET_CELL_SIZE_IN(i,sizeof(image_t));
   for(i=0; i< numberOutputBuffers; i++)
			SET_CELL_SIZE_OUT(0,sizeof(image_t));

]]>
</INIT_CODE> 


<MAIN_CODE>
<![CDATA[ 

	
	/* 
	 * This mode synchronizes all input buffers 
	 */
	for(i = MIN_AVAIL(); i>0; i--) {
		for(j=0; j<numberInputBuffers; ++j) {
		
		    /*
		     * point to input sample
		     */
			IT_IN(j);
			
			if(j < numberOutputBuffers) {
			    /*
			     * just send samples from input to output buffers
			     */
				if(IT_OUT(j)) {
					KrnOverflow("BLOCK_NAME_REPLACE",j);
					return(99);
				}
			    OUTIMAGE(j,0) = INIMAGE(j,0);

			}
			
			img=INIMAGE(j,0);
           /*
            * This is just to show haow to access the pixels
            */
        
           for(ii=0; ii< img.height; ii++) {
        
              for (jj=0; jj<img.width; jj++) {
                 fpixel=img.image_PP[ii][jj];
           
           
              }
           }
			 


		}
		    
	}


    return(0);


]]>
</MAIN_CODE> 

<WRAPUP_CODE>
<![CDATA[ 


]]>
</WRAPUP_CODE> 



</BLOCK> 

