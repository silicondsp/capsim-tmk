<BLOCK>
<LICENSE>
/*  Capsim (r) Text Mode Kernel (TMK) Star Library (Blocks)
 *    Copyright (C) 1989-2018  Silicon DSP  Corporation 
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *    http://www.silicondsp.com
 *    Silicon DSP  Corporation
 */
</LICENSE>
<BLOCK_NAME>
CHPStateSpace
</BLOCK_NAME> 


<DESC_SHORT>
Charge Pump Based on State Space Method
</DESC_SHORT>

<COMMENTS>
<![CDATA[ 

/*
 * 		Charge Pump Based on State Space Model.
 *
 * Generated by blockgen
 *
 * Floating Point Processor
 * Notes:
 *    This is a block generated from the floating point processor template
 *    It will input a sample, process it and output the processed
 *    sample.
 * 
 *    This block simply inputs the sample and outputs it.
 * Author: Sasan Ardalan
 * Initial 1989.
 * Updated to State Space 2018
 */
 
 /*
  *   Reference for State Space Approach:
  *   Hanumolu, P.K.; Brownlee, M.; Mayaram, K.; Un-Ku Moon,
  *   “Analysis of charge-pump phase-locked loops”, 
  *    Circuits and Systems I: Regular Papers, IEEE Transactions on Circuits and Systems I: 
  *    Fundamental Theory and Applications, Volume 51,  Issue 9,  Date: Sept. 2004,  Pages:  1665 – 1674
  *
  */

/*
 *
 */
]]>
</COMMENTS> 

<DECLARATIONS> 

   	int i;
   	float sample;
    int numberOfSamples;
    float up,dn;
 
   

    float vout;


	double i10;		//  Branch (1) current at incremental time t0.
	double i11;		//  Branch (1) current at incremental time t1.
	double i20;		//  Branch (2) current at incremental time t0.
	double i21;		//  Branch (2) current at incremental time t1.
	
	
	int vkUp;		//  Signal indicating to increase control voltage 'vk'.
	int vkDn;		//  Signal indicating to decrease control voltage 'vk'.
	
		//  Working variables.
		//  dv1 and dv2 are computed by eval().
		//  vs1 and vs2 are changed by advance().

	double dv1;		//  Calculated incremental V1 voltage.
	double dv2;		//  Calculated incremental V2 voltage.
//STATE	double vs1;		//  Stored voltage (Q1/C1) on C1 at incremental time t0.
//STATE	double vs2;		//  Stored voltage (Q2/C2) on C2 at incremental time t0.



	
	
	
	//   State Space
	double tt;
	double tdelay=10e-9;
	double a;
	double v1;
	double invC2;
	double aInv;
	double coeff;
	double beta;


	
	double T_;

	double g1;
	double g2;

	double w2;
	double wz;
	double Ip;

	int n=100;


	

</DECLARATIONS> 




<PARAMETERS>
        <PARAM>
               <DEF> R </DEF>
               <TYPE> float </TYPE>
               <NAME> R </NAME>
               <VALUE> 10000 </VALUE>
        </PARAM>
        <PARAM>
               <DEF> C1  pF </DEF>
               <TYPE> float </TYPE>
               <NAME> C11 </NAME>
               <VALUE> 100 </VALUE>
        </PARAM>
        <PARAM>
               <DEF> C2  pF </DEF>
               <TYPE> float </TYPE>
               <NAME> C22 </NAME>
               <VALUE> 10 </VALUE>
        </PARAM>
        <PARAM>
               <DEF> UP Current micro amps </DEF>
               <TYPE> float </TYPE>
               <NAME> UpCurrentValue </NAME>
               <VALUE> 1</VALUE>
        </PARAM>

       <PARAM>
               <DEF> Down Current micro amps </DEF>
               <TYPE> float </TYPE>
               <NAME> DnCurrentValue </NAME>
               <VALUE> 1</VALUE>
        </PARAM>
       <PARAM>
               <DEF> Sampling Rate </DEF>
               <TYPE> float </TYPE>
               <NAME> fs </NAME>
               <VALUE> 1e12</VALUE>
        </PARAM>
        <PARAM>
               <DEF> VDD </DEF>
               <TYPE> float </TYPE>
               <NAME> vdd </NAME>
               <VALUE> 1.0 </VALUE>
        </PARAM>
         <PARAM>
               <DEF> VSS </DEF>
               <TYPE> float </TYPE>
               <NAME> vss </NAME>
               <VALUE> 0.0 </VALUE>
        </PARAM>
</PARAMETERS>


<STATES>
   <STATE>
	<TYPE> float </TYPE>
	<NAME> halfVcc </NAME>
	<VALUE> 0 </VALUE>
   </STATE>
   <STATE>
	<TYPE> float </TYPE>
	<NAME> VTH </NAME>
	<VALUE> 0 </VALUE>
   </STATE>
   <STATE>
	<TYPE> float </TYPE>
	<NAME> iPu </NAME>
	<VALUE> 0 </VALUE>
   </STATE>
   <STATE>
	<TYPE> float </TYPE>
	<NAME> iPd </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

   <STATE>
	<TYPE> float </TYPE>
	<NAME> vs1_init </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

   <STATE>
	<TYPE> float </TYPE>
	<NAME> vs2_init </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

  <STATE>
	<TYPE> float </TYPE>
	<NAME> vs1 </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

   <STATE>
	<TYPE> float </TYPE>
	<NAME> vs2</NAME>
	<VALUE> 0 </VALUE>
   </STATE>



   <STATE>
	<TYPE> float </TYPE>
	<NAME> dTime </NAME>
	<VALUE> 0 </VALUE>
   </STATE>



   <STATE>
	<TYPE> float </TYPE>
	<NAME> C1 </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

   <STATE>
	<TYPE> float </TYPE>
	<NAME> C2 </NAME>
	<VALUE> 0 </VALUE>
   </STATE>



   <STATE>
	<TYPE> double </TYPE>
	<NAME> iPprev </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

  <STATE>
	<TYPE> double </TYPE>
	<NAME> iP </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

 <STATE>
	<TYPE> int </TYPE>
	<NAME> flag	 </NAME>
	<VALUE> 0 </VALUE>
   </STATE>
 <STATE>
	<TYPE> int </TYPE>
	<NAME> wflag	 </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

 <STATE>
	<TYPE> int </TYPE>
	<NAME> total	 </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

 <STATE>
	<TYPE> int </TYPE>
	<NAME> count	 </NAME>
	<VALUE> 0 </VALUE>
   </STATE>


  <STATE>
	<TYPE> double </TYPE>
	<NAME> vc </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

  <STATE>
	<TYPE> double </TYPE>
	<NAME> t </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

  <STATE>
	<TYPE> double </TYPE>
	<NAME> vctrlInit </NAME>
	<VALUE> 0 </VALUE>
   </STATE>


  <STATE>
	<TYPE> double </TYPE>
	<NAME> vctrl </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

  <STATE>
	<TYPE> double </TYPE>
	<NAME> vcInit </NAME>
	<VALUE> 0 </VALUE>
   </STATE>


  <STATE>
	<TYPE> double </TYPE>
	<NAME> tp </NAME>
	<VALUE> 0 </VALUE>
   </STATE>

</STATES>



<INPUT_BUFFERS>
	<BUFFER>
		<TYPE> float </TYPE>
		<NAME> upsig </NAME>
	</BUFFER>
	<BUFFER>
		<TYPE> float </TYPE>
		<NAME> dnsig </NAME>
	</BUFFER>	
	
	
</INPUT_BUFFERS>



<OUTPUT_BUFFERS>
	<BUFFER>
		<TYPE> float </TYPE>
		<NAME> y </NAME>
	</BUFFER>
</OUTPUT_BUFFERS>

<INIT_CODE>
<![CDATA[ 

halfVcc = (vdd - vss) / 2.0;
VTH = (vdd + vss) / 2.0;

iPu=DnCurrentValue*1e-06;
iPd=UpCurrentValue*1e-06;

vs1 = vs1_init;		//  Stored voltage (Q1/C1) on C1 at incremental time t0.
vs2 = vs2_init;		//  Stored voltage (Q2/C2) on C2 at incremental time t0.

dTime = 1.0/fs;

C1=C11*1e-12;
C2=C22*1e-12;


vctrlInit=0;
vcInit=0;

vctrl=0;
vc=0;


flag=0;
iPprev=0;

t=0;
count=0;
wflag=1;
total=0;


]]>
</INIT_CODE> 



<MAIN_CODE>
<![CDATA[ 




for (numberOfSamples = MIN_AVAIL(); numberOfSamples > 0; --numberOfSamples) {

    IT_IN(0);
    IT_IN(1);



       up=upsig(0);
       dn=dnsig(0);

	   vkUp = (up > VTH);
	   vkDn = (dn  > VTH);
	   iP = (iPu * (double) vkUp) - (iPd * (double) vkDn);

   
	
		// can make more efficient later by calculating non-changin in init.

		a=(C1+C2)/(R*C1*C2);
		aInv = 1/a;
		w2=1.0/(R*C2);
		wz=1.0/(R*C1);
	//++++++++++++++++++++++++++++

	    if(iPprev == 0 && iP !=0.0 && flag==1) {
		    flag=0;
			t=0;
			tp=0;
		}


			Ip=iP;

			g1=0;
			g2=aInv;

			if(iP != 0.0 && iPprev ==0.0) {
	                 vctrlInit=vctrl;
					 vctrl=vc;
			}

			if(iP != 0.0) {

			   tp += dTime;

	           flag=0;
			   g1=exp(-a*t);
			   g2=aInv*(1-exp(-a*t));


			    vctrl = vctrlInit*(g1+wz*g2)+vcInit*w2*g2+(Ip/C2)*(g2+wz*(g1-1)/(a*a)+wz*t/a);
			    vc=vctrlInit*wz*g2+vcInit*(g1+w2*g2)+(Ip/C2)*(wz*(g1-1)/(a*a)+wz*t/a);
			}
			if (iP==0.0  && !flag) {

	                        vctrlInit=vctrl;
	                        vcInit=vc;
				flag=1;
			}
			if (iP==0.0 && flag) {
				tt=t-tp;
			    g1=exp(-a*tt);
			    g2=aInv*(1-exp(-a*tt));

				vctrl=vctrlInit*(g1+wz*g2)+vcInit*w2*g2;
				vc=vctrlInit*wz*g2+vcInit*(g1+w2*g2);

			}
			//printf("%le\t%le\n",t,vctrl);

	        iPprev=iP;


	       t += dTime;
		   total += dTime;	
	
		vs1 =vc;
		vs2 =vctrl;
		
        vout=vs2;
	 





   
   	   /*
	    * ready output buffer for sample
	    * check for overflow
	    */
	   if(IT_OUT(0)) {
				KrnOverflow("CHPStateSpace",0);
				return(99);
	   }
	   /*
	    * output the sample
	    */
	   y(0)=vout;


}
    

]]>
</MAIN_CODE> 

<WRAPUP_CODE>
<![CDATA[ 


]]>
</WRAPUP_CODE> 



</BLOCK> 

