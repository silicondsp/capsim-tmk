<BLOCK>
<LICENSE>
/*  Capsim (r) Text Mode Kernel (TMK) Star Library (Blocks)
 *    Copyright (C) 1989-2016  Silicon DSP  Corporation 
 *
 *    This library is free software; you can redistribute it and/or
 *    modify it under the terms of the GNU Lesser General Public
 *    License as published by the Free Software Foundation; either
 *    version 2.1 of the License, or (at your option) any later version.
 *
 *    This library is distributed in the hope that it will be useful,
 *    but WITHOUT ANY WARRANTY; without even the implied warranty of
 *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *    Lesser General Public License for more details.
 *
 *    You should have received a copy of the GNU Lesser General Public
 *    License along with this library; if not, write to the Free Software
 *    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 *    http://www.silicondsp.com
 *    Silicon DSP  Corporation
 */
</LICENSE>
<BLOCK_NAME>
DBN
</BLOCK_NAME> 


<DESC_SHORT>
Add short description here. Will appear in HTML documentation.
</DESC_SHORT>

<COMMENTS>
<![CDATA[ 

/*
 * 		DBN()
 *
 * Generated by blockgen
 *
 * Floating Point Processor
 * Notes:
 *    This is a block generated from the floating point processor template
 *    It will input a sample, process it and output the processed
 *    sample.
 * 
 *    This block simply inputs the sample and outputs it.
 *    
 * Programmer: 
 * Date: 
 * Modified: 
 *
 */
]]>
</COMMENTS> 

<DECLARATIONS> 

   	int i;
   	float sample;
   	float inState;

</DECLARATIONS> 

<PARAMETERS>
        <PARAM>
               <DEF> N  ( Divide by N ) </DEF>
               <TYPE> int </TYPE>
               <NAME> N </NAME>
               <VALUE> 1 </VALUE>
        </PARAM>
        <PARAM>
               <DEF> VDD </DEF>
               <TYPE> float </TYPE>
               <NAME> vdd </NAME>
               <VALUE> 1.0 </VALUE>
        </PARAM>
         <PARAM>
               <DEF> VSS </DEF>
               <TYPE> float </TYPE>
               <NAME> vss </NAME>
               <VALUE> 0.0 </VALUE>
        </PARAM>

      
        
        
</PARAMETERS>


<STATES>
	<STATE>
		<TYPE> float </TYPE>
		<NAME> lastIn </NAME>
		<VALUE> 0 </VALUE>
	</STATE>
	<STATE>
		<TYPE> int </TYPE>
		<NAME> count </NAME>
		<VALUE> 0 </VALUE>
	</STATE>
	
	<STATE>
		<TYPE> float </TYPE>
		<NAME> halfVcc </NAME>
		<VALUE> 0 </VALUE>
	</STATE>	
	<STATE>
		<TYPE> float </TYPE>
		<NAME> vout </NAME>
		<VALUE> 0 </VALUE>
	</STATE>		
</STATES>



<INPUT_BUFFERS>
	<BUFFER>
		<TYPE> float </TYPE>
		<NAME> x </NAME>
	</BUFFER>
</INPUT_BUFFERS>



<OUTPUT_BUFFERS>
	<BUFFER>
		<TYPE> float </TYPE>
		<NAME> y </NAME>
	</BUFFER>
</OUTPUT_BUFFERS>

<INIT_CODE>
<![CDATA[ 
     halfVcc = (vdd - vss) / 2.0;

]]>
</INIT_CODE> 




<MAIN_CODE>
<![CDATA[ 




while(IT_IN(0)) {
       sample=x(0);
       inState = sample > halfVcc;
 
	    if (inState && !lastIn || !inState && lastIn) {
		     ++count;
		    if (count >= N) {
			     if (vout > halfVcc) {
			     
			              vout=vss;
				         
				              //vdiv=_vss->v();
			     } else {
				         vout=vdd;
				         //vdiv=_vcc->v();
			     }
			     count = 0;
		    }
	    } 
	    lastIn = inState;
  
   
   	   /*
	    * ready output buffer for sample
	    * check for overflow
	    */
	   if(IT_OUT(0)) {
				KrnOverflow("DBN",0);
				return(99);
	   }
	   /*
	    * output the sample
	    */
	   y(0)=vout;


}
    

]]>
</MAIN_CODE> 

<WRAPUP_CODE>
<![CDATA[ 


]]>
</WRAPUP_CODE> 



</BLOCK> 

