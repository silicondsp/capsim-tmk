



<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">


<html>


<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></meta>
<title>



predftf 



</title>
<style type="text/css">
<!--
.style2 {font-size: 12px}
.style3 {
	font-size: x-large;
	font-weight: bold;
}
.style5 {font-family: "Courier New", Courier, mono}
-->
</style>
</head>
<body>

<h1>



predftf 



<a name="top"></a></h1>
<p><a href="http://www.xcad.com">Capsim</a> Block Documentation </p>
<ul>
  <li><a href="#license">License</a></li>
  <li><a href="#description">Description</a></li>
  <li><a href="#inputs">Input Connections</a></li>
  <li><a href="#outputs">Output Connections</a></li>
  <li><a href="#parameters">Parameters</a></li>
  <li><a href="#Results">Result Variables</a></li>
  <li><a href="#states">States</a></li>
  <li><a href="#declarations">Declarations</a></li>
  <li><a href="#initialization">Initialization Code</a></li>
  <li><a href="#maincode">Main Code</a></li>
  <li><a href="#wrapup">Wrapup Code</a></li>
</ul>





<h2>Short Description</h2><P>


This star implements a multichannel input/output FIR predictor, which is adapted using the least squares Fast Transversal Filter algorithm.


<h6><a href="#top">Top</a></h6>
<table width="746" border="1" cellspacing="1" cellpadding="1">
  <caption>
  <span class="style3">  Parameters<a name="parameters"></a> </span>
  </caption>
  <tr>
    <th width="58" scope="col">Num</th>
    <th width="373" scope="col">Description</th>
    <th width="80" scope="col">Type</th>
    <th width="98" scope="col">Name</th>
    <th width="109" scope="col">Default Value </th>
  </tr>

  


 <tr>
    <td>
    
    0
    
    </td>
    <td>
    
     Name of ASCII input specification file
    
    </td>
    <td>
    
    file
    
    </td>
    <td>
    
    ifile_name
    
    </td>
    <td>
    
    prfile
    
    </td>
    <td>
     </tr>
    
 



 <tr>
    <td>
    
    1
    
    </td>
    <td>
    
     Name of ASCII output specification file
    
    </td>
    <td>
    
    file
    
    </td>
    <td>
    
    ofile_name
    
    </td>
    <td>
    
    prfileo
    
    </td>
    <td>
     </tr>
    
 



 <tr>
    <td>
    
    2
    
    </td>
    <td>
    
    Forgetting factor <= 1.0
    
    </td>
    <td>
    
    float
    
    </td>
    <td>
    
    lambda
    
    </td>
    <td>
    
    1.0
    
    </td>
    <td>
     </tr>
    
 



 <tr>
    <td>
    
    3
    
    </td>
    <td>
    
    Initial value: forward prediction energy value
    
    </td>
    <td>
    
    float
    
    </td>
    <td>
    
    delta
    
    </td>
    <td>
    
    1e-4
    
    </td>
    <td>
     </tr>
    
 



 <tr>
    <td>
    
    4
    
    </td>
    <td>
    
     Number of samples to skip before starting adaptation
    
    </td>
    <td>
    
    int
    
    </td>
    <td>
    
    wait
    
    </td>
    <td>
    
    0
    
    </td>
    <td>
     </tr>
    
 



 <tr>
    <td>
    
    5
    
    </td>
    <td>
    
     Number of samples to adapt.Freeze after this number of iterations
    
    </td>
    <td>
    
    int
    
    </td>
    <td>
    
    adapt
    
    </td>
    <td>
    
    -1
    
    </td>
    <td>
     </tr>
    
 



</table>




<h6><a href="#top">Top</a></h6>
<table width="746" border="1" cellspacing="1" cellpadding="1">
  <caption>
  <span class="style3">  States<a name="states"></a> </span>
  </caption>
  <tr>
    <th width="58" scope="col">Num</th>    
    <th width="80" scope="col">Type</th>
    <th width="98" scope="col">Name</th>
    <th width="109" scope="col">Initial Value </th>
    <th width="373" scope="col">Description</th>
  </tr>

  


 <tr>
    <td>
    
    0
    
    </td>
    <td>
    
  
    int
    
    </td>
    <td>
    
    counter
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    1
    
    </td>
    <td>
    
  
    float*
    
    </td>
    <td>
    
    inpower
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    2
    
    </td>
    <td>
    
  
    float*
    
    </td>
    <td>
    
    epower
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    3
    
    </td>
    <td>
    
  
    int
    
    </td>
    <td>
    
    p
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    4
    
    </td>
    <td>
    
  
    int
    
    </td>
    <td>
    
    q
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    5
    
    </td>
    <td>
    
  
    FILE*
    
    </td>
    <td>
    
    fp
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    6
    
    </td>
    <td>
    
  
    int*
    
    </td>
    <td>
    
    orders
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    7
    
    </td>
    <td>
    
  
    int
    
    </td>
    <td>
    
    N
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    8
    
    </td>
    <td>
    
  
    float*
    
    </td>
    <td>
    
    z
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    9
    
    </td>
    <td>
    
  
    float*
    
    </td>
    <td>
    
    Z
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    10
    
    </td>
    <td>
    
  
    float*
    
    </td>
    <td>
    
    F
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    11
    
    </td>
    <td>
    
  
    float*
    
    </td>
    <td>
    
    B
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    12
    
    </td>
    <td>
    
  
    float*
    
    </td>
    <td>
    
    C
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    13
    
    </td>
    <td>
    
  
    float*
    
    </td>
    <td>
    
    Cp
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    14
    
    </td>
    <td>
    
  
    float*
    
    </td>
    <td>
    
    W
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    15
    
    </td>
    <td>
    
  
    float*
    
    </td>
    <td>
    
    Efi
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    16
    
    </td>
    <td>
    
  
    float*
    
    </td>
    <td>
    
    Eb
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



 <tr>
    <td>
    
    17
    
    </td>
    <td>
    
  
    float
    
    </td>
    <td>
    
    gamma
    
    </td>
    <td>
    
    
    
    </td>
    <td>
    
      
    
    </td>
     </tr>
    
 



</table>




<h6><a href="#top">Top</a></h6>
<h2>Declarations<a name="declarations"></a></h2>
<table width="754" height="98" border="1" cellpadding="1" cellspacing="1">
  <tr>
    <th class="style5" scope="col"><div align="left"> 
      <pre>

 

        int i,j,k,jj;
        float error[Mch];
        int index;              /* convenience counter */
        float estimate;
        float cb[Mch];          /* last p elements of Cp[ ] */
        float a[Mch];           /* auxilliary (temp) vector */
        float temp[Mch+1];      /* small working vector */
        float sum;              /* working accumulator */
        float ef[Mch];          /* forward est. error */
        float efp[Mch];         /* forward pred. error */
        float eb[Mch];          /* backward est. err. */
        float ebp[Mch];         /* b. prediction error */
        float gmp;              /* extended gain estimation error */



</pre>
    </div></th>
  </tr>
</table>




<h6><a href="#top">Top</a></h6>
<h2>Initialization Code<a name="initialization"></a></h2>
<table width="754" height="98" border="1" cellpadding="1" cellspacing="1">
  <tr>
    <th class="style5" scope="col"><div align="left"> 
      <pre>


 

        if(NO_OUTPUT_BUFFERS() < 1) {
                fprintf(stderr,"pred: no output data channels\n");
                return(1);
        }
        if(NO_INPUT_BUFFERS() < NO_OUTPUT_BUFFERS() +1) {
                fprintf(stderr,"pred: not enough input buffers\n");
                return(2);
        }
        if((fp = fopen(ifile_name, "r")) == NULL) {
                fprintf(stderr,"pred: can't find filter specification file\n");
                return(3);
        }
        fscanf(fp, "%d", &q);
        fscanf(fp, "%d", &p);
        if(p > Mch || q > Mch) {
                fprintf(stderr,"pred: more than %d i/o channels\n",Mch);
                return(4);
        }
        if( q != NO_OUTPUT_BUFFERS() ||
            p != NO_INPUT_BUFFERS() - q ) {
                fprintf(stderr,
                "pred: spec file %s does not agree with topology\n",
                        ifile_name);
                return(5);
        }
        if(   (orders = (int*)calloc(p,sizeof(int))) == NULL
           || (z = (float*)calloc(p,sizeof(float))) == NULL
           || (inpower = (float*)calloc(p,sizeof(float))) == NULL
           || (epower = (float*)calloc(q,sizeof(float))) == NULL
           || (Efi = (float*)calloc(p*p,sizeof(float))) == NULL
           || (Eb = (float*)calloc(p*p,sizeof(float))) == NULL) {
                fprintf(stderr,"pred: can't allocate space\n");
                return(6);
        }
        N = 0;
        for(j=0; j<p; j++) {
                if((fscanf(fp, "%d", &orders[j])) != 1) {
                        fprintf(stderr,"pred: problem in input file %s\n",
                                ifile_name);
                        return(7);
                }
                N += orders[j];
        }
        if(   (W = (float*)calloc(N*q,sizeof(float))) == NULL
           || (Z = (float*)calloc(N,sizeof(float))) == NULL
           || (F = (float*)calloc(p*N,sizeof(float))) == NULL
           || (B = (float*)calloc(p*N,sizeof(float))) == NULL
           || (C = (float*)calloc(N,sizeof(float))) == NULL
           || (Cp = (float*)calloc(N+p,sizeof(float))) == NULL) {
                fprintf(stderr,"pred: can't allocate space\n");
                return(6);
        }
        for(k=0; k<q; k++) {
                for(i=0; i<N; i++) {
                        if((fscanf(fp,"%f",&W[i*q+k])) != 1) {
                                fprintf(stderr,"pred: problem in input file %s\n",
                                        ifile_name);
                                return(7);
                        }
                }
        }
        fclose(fp);
        /* set up unit delay in error channels */
        for(k=0; k<q; k++)
                SET_DMIN_IN(k,1);
        gamma = 1.0;
        for (i=0; i<p; i++) {
                Efi[i*p+i] = 1./delta;
                Eb[i*p+i] = delta;
                inpower[i] = delta;
                for (j=0; j<i; j++) {
                        Efi[i*p+j] = Efi[j*p+i] = 0.0;
                        Eb[i*p+j] = Eb[j*p+i] = 0.0;
                }
        }




</pre>
    </div></th>
  </tr>
</table>




<h6><a href="#top">Top</a></h6>
<h2>Main Code<a name="maincode"></a></h2>
<table width="754" height="98" border="1" cellpadding="1" cellspacing="1">
  <tr>
    <th class="style5" scope="col"><div align="left"> 
      <pre>


 


#if 0
if(MIN_AVAIL() == 0) return(0);
#endif
for(jj = MIN_AVAIL(); jj>0; jj--) {

if(wait > 0) {
        wait--;
        for(k=0; k<q; k++) {
                IT_IN(k);
                if(IT_OUT(k)) {
                        KrnOverflow("prftf",k);
                        return(99);
                }
                OUTF(k,0) = 0;
        }
        for(j=0; j<p; j++)
                IT_IN(q+j);
        return(0);
}

/*** Normal Operation ***/
/* input new data and create vector */
for(j=0; j<p; j++) {
        IT_IN(q+j);
        z[j] = INF(q+j,0);
        /* update input power state */
        inpower[j] *= .96;
        inpower[j] += .04 * z[j] *z[j];
}
/* input unit-delayed error(s) */
for(k=0; k<q; k++) {
        IT_IN(k);
        error[k] = INF(k,1);
        /* update error power state */
        epower[k] *= .96;
        epower[k] += .04 * error[k] * error[k];

}
if(adapt == 0) goto resume;

/********* ftf predictor ********************************************/

/**** Joint Process ****/
for(k=0; k<q; k++) {
        /* e(n-1|n-2) is computed externally */
        /* find e(n-1|n-1) (14) */
        /* update W(n-2) -> W(n-1)  (15) */
        for(i=0; i<N; i++)
                W[i*q+k] += C[i] * error[k] * gamma;
}

/* calculate e sub f (n|n-1)  (1) */
/* calculate e sub f (n|n)  (2) */
for(j=0; j<p; j++) {
        sum = 0;
        for(i=0; i<N; i++)
                sum += F[i*p+j] * Z[i];
        efp[j] = z[j] - sum;
        ef[j] = efp[j] * gamma;
}

/* Update auxilliary vector a(n) (3a) */
for(j=0; j<p; j++) {
        sum = 0;
        for(i=0; i<p; i++) {
                sum += Efi[j*p+i] * efp[i];
        }
        a[j] = sum / lambda;
}
/* update gamma sub + (n)  (3b) */
sum = 0;
for(j=0; j<p; j++)
        sum += ef[j] * a[j];
gmp = gamma / (1.+ sum);
/* update epsilon sub f sup -1 (n) (4) */
for(j=0; j<p; j++) {
        Efi[j*p+j] /= lambda;
        temp[j] = gmp * a[j];
        Efi[j*p+j] -= temp[j] * a[j];
        for(i=0; i<j; i++) {
                Efi[i*p+j] /= lambda;
                Efi[i*p+j] -= temp[j] * a[i];
                Efi[j*p+i] = Efi[i*p+j];
        }
}
/* update C sub N+p sup f (n)  (5a) */
for(j=0; j<p; j++)
        Cp[j] = a[j];
for(i=0; i<N; i++) {
        sum = 0;
        for(j=0; j<p; j++)
                sum += F[i*p+j] * a[j];
        Cp[i+p] =  C[i] - sum;
}
/* form Cbp = Sb*Sf'*Cfp (re-arrange Cp)  (5b) */
index = p-1;
for(j=0; j<p-1; j++) {
        index += orders[j];
        temp[j] = Cp[index];
        Cp[index] = Cp[j+1];
}
for(i=1; i<N; i++)
        Cp[i] = Cp[i+p-1];
for(j=0; j<p-1; j++)
        Cp[N+j] = temp[j];
/* define c sub + sup b (n)  (5b) */
for(j=0; j<p; j++)
        cb[j] = Cp[N+j];
/* update F(n)  (6) */
for(i=0; i<N; i++) {
        for(j=0; j<p; j++)
                F[i*p+j] += C[i] * ef[j];
}
/* calculate e sub b (n|n-1) (7*) */
for(j=0; j<p; j++) {
        sum = 0;
        for(i=0; i<p; i++)
                sum += Eb[j*p+i] * cb[i];
        ebp[j] = lambda * sum;
}
/* update gamma (n)  (8) */
sum = 0;
for(j=0; j<p; j++)
        sum += ebp[j] * cb[j];
sum = 1. - sum * gmp;

if(sum < 0 ) {
        /* Rescue: restart algorithm kernel */
        fprintf(stderr,"predftf: rescue @%d\n",counter);
        gamma = 1.0;
        for (i=0; i<N; i++) {
                C[i] = 0;
                for(j=0; j<p; j++)
                        F[i*p+j] = B[i*p+j] = 0;
        }
        for (i=0; i<p; i++) {
                Efi[i*p+i] = 1./inpower[i];
                Eb[i*p+i] = inpower[i];
                for (j=0; j<i; j++) {
                        Efi[i*p+j] = Efi[j*p+i] = 0.0;
                        Eb[i*p+j] = Eb[j*p+i] = 0.0;
                }
        }
        goto resume;
}

gamma = gmp / sum;
/* calculate e sub b (n|n)  (9) */
for(j=0; j<p; j++)
        eb[j] = gamma * ebp[j];
/* update epsilon sub b (10) */
for(i=0; i<p; i++) {
        Eb[i*p+i] *= lambda;
        Eb[i*p+i] += ebp[i] * eb[i];
        for(j=0; j<i; j++) {
                Eb[i*p+j] *= lambda;
                Eb[i*p+j] += ebp[i] * eb[j];
                Eb[j*p+i] = Eb[i*p+j];
        }
}
/* update C sub N   (11) */
for (i=0; i<N; i++) {
        sum = 0;
        for(j=0; j<p; j++)
                sum += B[i*p+j] * cb[j];
        C[i] = Cp[i] + sum;
}
/* update B sub N  (12) */
for(i=0; i<N; i++)
        for(j=0; j<p; j++)
                B[i*p+j] += C[i] * eb[j];

/********************************************************************/
resume:

/* create z sub N (n) by shifting z sub N (n-1) */
for(i=N-1; i>0; i--)
        Z[i] = Z[i-1];
index = 0;
for(j=0; j<p; j++) {
        Z[index] = z[j];
        index += orders[j];
}

for(k=0; k<q; k++) {
        /* compute estimate with old filter */
        estimate = 0;
        for(i=0; i<N; i++)
                estimate += W[i*q+k] * Z[i];

        /* output estimate and wait for error */
        if(IT_OUT(k) ) {
                        KrnOverflow("prftf",k);
                        return(99);
        }
        OUTF(k,0) = estimate;
}

counter++;
if(adapt > 0) adapt--;

}
return(0);





</pre>
    </div></th>
  </tr>
</table>




<h6><a href="#top">Top</a></h6>
<h2>Wrapup Code<a name="wrapup"></a></h2>
<table width="754" height="98" border="1" cellpadding="1" cellspacing="1">
  <tr>
    <th class="style5" scope="col"><div align="left"> 
      <pre>


 

for(j=0; j<p; j++)
        fprintf(stderr,"predftf: input power(%d) = %#g\n",j,inpower[j]);
for(k=0; k<q; k++) {
        if(epower[k] <= 0) epower[k] = 1e-30;
        fprintf(stderr,"predftf: pred error power(%d) = %#g = %#.3g dB\n",
               k,epower[k],10*log10(epower[k]));
}
if((fp = fopen(ofile_name, "w")) == NULL) {
        fprintf(stderr,"pred: can't open output file\n");
        return(1);
}
fprintf(fp, "%d\n", q);
fprintf(fp, "%d\n", p);
for(j=0; j<p; j++)
        fprintf(fp, "%d \t", orders[j]);
fprintf(fp, "\n");
for(k=0; k<q; k++) {
        index = 0;
        for(j=0; j<p; j++) {
                fprintf(fp, "\n");
                for(i=0; i<orders[j]; i++) {
                        fprintf(fp, "%g   \t", W[index*q+k]);
                        if((i+1)%5 == 0) fprintf(fp, "\n");
                        index++;
                }
                fprintf(fp, "\n");
        }
        fprintf(fp, "\n");
}
fclose(fp);
free(inpower);free(epower);
free(orders);free(z);free(Z);
free(F);free(B);free(C);free(W);
free(Cp);free(Efi);free(Eb);




</pre>
    </div></th>
  </tr>
</table>




<h6><a href="#top">Top</a></h6>
<h2>License<a name="license"></a></h2>
<table width="754" height="98" border="1" cellpadding="1" cellspacing="1">
  <tr>
    <th class="style5" scope="col"><div align="left"> 
      <pre>


/*  Capsim (r) Text Mode Kernel (TMK) Star Library (Blocks)
    Copyright (C) 1989-2017  Silicon DSP Corporation

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

    http://www.silicondsp.com
    Silicon DSP  Corporation
    Las Vegas, Nevada
*/


</pre>
    </div></th>
  </tr>
</table>




<h6><a href="#top">Top</a></h6>
<h2>Description<a name="description"></a></h2>
<table width="754" height="98" border="1" cellpadding="1" cellspacing="1">
  <tr>
    <th class="style5" scope="col"><div align="left"> 
      <pre>


 

/**********************************************************************
                predftf()
***********************************************************************
This star implements a multichannel input/output FIR predictor, which is
adapted using the least squares Fast Transversal Filter algorithm.
It can be used as an equalizer, FSE, DFE, or echo canceller.
An arbitrary number p input channels are transversal filtered
to produce an arbitrary number q output estimate signals.
Note: each output buffer connected to this star implies a separate
output channel, and identically numbered error input channel.
Input signal channels are then connected to higher numbered buffers.
It is assumed that the estimate error is computed externally.
Do NOT implement an external (causality) unit-delay from
output estimate to input error; this delay is handled automatically.
Param.  1 - Name of ASCII input specification file.  Filter orders
                and initial tap values are given.  default => prfile
The proper specification file format is:
  (int) # output channels, q
  (int) # input channels, p
  (int) order of in ch.#1  . . .  (int) order of in ch.#p
  (float) ch.#1, tap 1 . . .  (float) ch.#1, tap last
      .                                                {output ch.1}
      .
  (float) ch.#p, tap 1 . . .  (float) ch.#p, tap last
   .
   .
   .
  (float) ch.#1, tap 1 . . .  (float) ch.#1, tap last
      .                                                {output ch.q}
      .
  (float) ch.#p, tap 1 . . .  (float) ch.#p, tap last
Param.  2 - Name of output file, for final adapted filter values.
          default => prfileo.  The file is written in proper
          input-file format.  This file can then be used to initialize
          the filter for the next run, if desired.
It is assumed that each output prediction filter will create one
estimate output for EACH input sample/error sample pair.
Any decimation, etc. must occur externally.
Param.  3 - (float) lambda.  data forgetting factor.  default => 1.0
          Lambda = 1.0 implies no long term adaptation occurs.
        4 - (float) delta.  initial value, forward prediction energy.
          default => 1e-4
        5 - (int) wait.  number of samples to skip before starting
          adaptation.  The predictor still inputs samples, and
          outputs a zero estimate.  default => 0
        6 - (int) adapt.  number of samples to adapt filter.  After
          this number, filter taps are fixed, and estimates are still
          produced.  default => -1  (implies always adapt)
<NAME>
predftf
</NAME>
<DESCRIPTION>
This star implements a multichannel input/output FIR predictor, which is
adapted using the least squares Fast Transversal Filter algorithm.
It can be used as an equalizer, FSE, DFE, or echo canceller.
An arbitrary number p input channels are transversal filtered
to produce an arbitrary number q output estimate signals.
Note: each output buffer connected to this star implies a separate
output channel, and identically numbered error input channel.
Input signal channels are then connected to higher numbered buffers.
It is assumed that the estimate error is computed externally.
Do NOT implement an external (causality) unit-delay from
output estimate to input error; this delay is handled automatically.
Param.  1 - Name of ASCII input specification file.  Filter orders
                and initial tap values are given.  default => prfile
The proper specification file format is:
  (int) # output channels, q
  (int) # input channels, p
  (int) order of in ch.#1  . . .  (int) order of in ch.#p
  (float) ch.#1, tap 1 . . .  (float) ch.#1, tap last
      .                                                {output ch.1}
      .
  (float) ch.#p, tap 1 . . .  (float) ch.#p, tap last
   .
   .
   .
  (float) ch.#1, tap 1 . . .  (float) ch.#1, tap last
      .                                                {output ch.q}
      .
  (float) ch.#p, tap 1 . . .  (float) ch.#p, tap last
Param.  2 - Name of output file, for final adapted filter values.
          default => prfileo.  The file is written in proper
          input-file format.  This file can then be used to initialize
          the filter for the next run, if desired.
It is assumed that each output prediction filter will create one
estimate output for EACH input sample/error sample pair.
Any decimation, etc. must occur externally.
Param.  3 - (float) lambda.  data forgetting factor.  default => 1.0
          Lambda = 1.0 implies no long term adaptation occurs.
        4 - (float) delta.  initial value, forward prediction energy.
          default => 1e-4
        5 - (int) wait.  number of samples to skip before starting
          adaptation.  The predictor still inputs samples, and
          outputs a zero estimate.  default => 0
        6 - (int) adapt.  number of samples to adapt filter.  After
          this number, filter taps are fixed, and estimates are still
          produced.  default => -1  (implies always adapt)
</DESCRIPTION>
<PROGRAMMERS>
Programmer: L.J. Faber
Date: April 1988
Modified: May 1988  add multichannel output
Modified: June 1988  estimate-referenced prediction energy
Modified: Aug 1988  est. input power.  new parameter delta.
Modified: Sept 1988  add parameters 5,6 and associated.
</PROGRAMMERS>
*/




</pre>
    </div></th>
  </tr>
</table>




</body>
</html>


